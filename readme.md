== Цикл ==

    array := [3]int{1, 2, 3}

    for index, value := range array {
    	fmt.Printf("Индекст %d и значение %d \n" , index, value)
    }

== Массивы ==

array := [3]int{1, 2, 3} = обычный массив в котором определены заранее данные и длина

Массивы в Go являются значениями, а не ссылками. Это значит, что при передаче массива в функцию или присваивании его другой переменной создается копия массива.

Пример:
arr1 := [3]int{1,2,3}
arr2 := arr1
arr2[0] = 10

    fmt.Println(arr1)
    fmt.Println(arr2)

[Вывод]

[1 2 3]
[10 2 3]
Ограничения массивов
Размер массива должен быть известен на этапе компиляции.
Массивы не могут изменять свой размер после создания.
Из-за фиксированного размера массивы используются реже, чем срезы (slices), которые более гибкие.

Когда использовать массивы?
Массивы полезны, когда:
Ты точно знаешь размер коллекции.
Тебе нужна фиксированная структура данных.
Ты работаешь с низкоуровневыми операциями, где важна производительность.
В остальных случаях чаще используются срезы (slices), которые более гибкие и удобные.

== Срезы ==

Срезы — это одна из самых мощных и часто используемых структур данных в Go. Они похожина массивы, но имеют динамический размер, что делает их гораздо более гибкими.

Срез — это динамический массив, который может изменять свой размер. В отличие от массива, срез не имеет фиксированной длины. Он состоит из трех компонентов:

- Указатель на массив (срез ссылается на массив, который хранит данные).
- Длина (length) — количество элементов в срезе.
- Емкость (capacity) — максимальное количество элементов, которые можно хранить в срезе без выделения новой памяти.

array := [3]int{1,2,3}

slice := array[0:3]

или

slice := make([]int, 3, 5)

или

slice := []int{1,2,3,4,5}

fmt.Println("Длина:", len(slice)) // 5
fmt.Println("Емкость:", cap(slice)) // 5

Срезы являются ссылочными типами. Это значит, что если ты изменяешь срез, все переменные, которые ссылаются на этот срез, тоже "увидят" изменения.

Копия:
slice1 := []int{1, 2, 3}

    slice2 := make([]int, len(slice1))

    copy(slice2, slice1)

    slice2[0] = 24

    fmt.Print(slice1)
    fmt.Print(slice2)

== Карты, хеш мапы ==
obj := map[string]string{
"name": "Igor",
}

value, exists := m["orange"]
if exists {
fmt.Println("orange:", value)
} else {
fmt.Println("orange not found")
}

Для удаления элемента из карты используется функция delete:
delete(m, "banana")

Для перебора всех элементов карты используй цикл for с range:
for key, value := range m {
fmt.Printf("Ключ: %s, Значение: %d\n", key, value)
}

var m map[string]int
m["apple"] = 5 // panic: assignment to entry in nil map
Всегда инициализируй карту с помощью make или литерала.

Карты передаются по ссылке. Если передать карту в функцию, изменения будут видны в оригинальной карте.

Карты могут быть вложенными, то есть значениями карты могут быть другие карты.

Пример:
m := map[string]map[string]int{
"fruits": {
"apple": 5,
"banana": 3,
},
"vegetables": {
"carrot": 10,
"potato": 7,
},
}

== Функции ==
Возврат нескольких значений
В Go функция может возвращать несколько значений. Это часто используется для возврата результата и ошибки.

func divide(a, b float64) (float64, error) {
if b == 0 {
return 0, fmt.Errorf("деление на ноль")
}
return a / b, nil
}
Пример вызова:
result, err := divide(10, 2)
if err != nil {
fmt.Println("Ошибка:", err)
} else {
fmt.Println("Результат:", result)
}

В Go можно указать имена для возвращаемых значений. Они работают как переменные внутри функции.
func rectProps(length, width float64) (area, perimeter float64) {
area = length _ width
perimeter = 2 _ (length + width)
return // Возврат area и perimeter
}
популярные пакеты для работы с данными slices , container, strings, sort, maps
[Структура]
myapp/
├── cmd/
│ └── myapp/
│ └── main.go
├── internal/
│ ├── config/
│ │ └── config.go
│ ├── handlers/
│ │ └── handlers.go
│ └── models/
│ └── models.go
├── pkg/
│ └── utils/
│ └── utils.go
├── go.mod
└── go.sum

cmd/myapp/main.go — точка входа в приложение.
internal/ — код, который должен быть доступен только внутри модуля.
config/ — конфигурация приложения.
handlers/ — обработчики HTTP-запросов.
models/ — модели данных.
pkg/utils/ — код, который может быть использован другими модулями (например, утилиты).

Ключевое слово defer в Go используется для отложенного выполнения функции или метода. Когда вы пишете defer, функция, следующая за ним, будет выполнена не сразу, а перед возвратом из текущей функции.
